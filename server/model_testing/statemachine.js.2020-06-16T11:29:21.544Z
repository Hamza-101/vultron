const assert = require("assert");
const hex2ascii = require('hex2ascii')
const Machine = require("xstate").Machine;
const createModel = require("@xstate/test").createModel;

let asyncFlag = false;
const MAX_COUNT = 60;

function revertAsyncFlag() {
  asyncFlag = !asyncFlag;
}


// contract interface 

class BlindAuction {
  constructor(fuzzer) {
    this.address = "0x102d00a2ae779339e7a5dd369224035c9446df4f";
    this.name = "BlindAuction";
    this.fuzzer = fuzzer;
  }

  async close() {
    let fuzz = await this.fuzzer.full_fuzz_fun("BlindAuction", this.address, "close");
    return fuzz;
  }

  async unbid() {
    let fuzz = await this.fuzzer.full_fuzz_fun("BlindAuction", this.address, "unbid");
    return fuzz;
  }

  async withdraw() {
    let fuzz = await this.fuzzer.full_fuzz_fun("BlindAuction", this.address, "withdraw");
    return fuzz;
  }

  async reveal() {
    let fuzz = await this.fuzzer.full_fuzz_fun("BlindAuction", this.address, "reveal");
    return fuzz;
  }

  async cancelRB() {
    let fuzz = await this.fuzzer.full_fuzz_fun("BlindAuction", this.address, "cancelRB");
    return fuzz;
  }

  async state() {
    let fuzz = await this.fuzzer.full_fuzz_fun("BlindAuction", this.address, "state");
    return fuzz;
  }

  async cancelABB() {
    let fuzz = await this.fuzzer.full_fuzz_fun("BlindAuction", this.address, "cancelABB");
    return fuzz;
  }

  async finish() {
    let fuzz = await this.fuzzer.full_fuzz_fun("BlindAuction", this.address, "finish");
    return fuzz;
  }

  async bid() {
    let fuzz = await this.fuzzer.full_fuzz_fun("BlindAuction", this.address, "bid");
    return fuzz;
  }

}
// state machine context
class StateMachineCtx {
  constructor(fsmreplayer, fuzzer) {
    this.BlindAuction = new BlindAuction(fuzzer);

    this.state = {
      "id": "FSM#2"
    };
    this.fuzzer = fuzzer;
    this.fsmreplayer = fsmreplayer;
  }
  async initialize() {
    this.BlindAuction.address = await this.fsmreplayer.initialize();
  }
  static getInstance(fsmreplayer, fuzzer) {
    if (!StateMachineCtx.instance)
      StateMachineCtx.instance = new StateMachineCtx(fsmreplayer, fuzzer);
    return StateMachineCtx.instance;
  }
  async getState() {
    //TO DO, set what your state means and how to get the state
    if (this.BlindAuction.state) {
      let ret = await this.BlindAuction.state();
      this.state = BigInt(ret.receipt.result.output.toString());
    } else if (this.BlindAuction.stage) {
      let ret = await this.BlindAuction.stage();
      this.state = BigInt(ret.receipt.result.output.toString());
    } else {
      this.state = null;
    }
    console.log("state:", this.state);
    return this.state;
  }
  // action_functions_mapping
  async action_bid() {
    let ret = [];
    if (asyncFlag) {
      // bcos success status:0
      let executeStatus = BigInt(0);
      let ctx = StateMachineCtx.getInstance();
      let count = 0;
      // PreCondition. 
      let preState = await ctx.getState();
      assert(null == preState || preState == 0 || preState == 0, "preCondition violated: current state is " + preState);

      let retbid = await StateMachineCtx.getInstance().BlindAuction.bid();
      ret.push(retbid);
      console.log("current test case: ", BigInt(retbid.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
      executeStatus += BigInt(retbid.receipt.status.toString());
      while (executeStatus != 0 && count < MAX_COUNT) {
        count++;
        executeStatus = BigInt(0);
        let retbid = await StateMachineCtx.getInstance().BlindAuction.bid();
        ret.push(retbid);
        console.log("current test case: ", BigInt(retbid.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
        executeStatus += BigInt(retbid.receipt.status.toString());
      }

      if (count >= MAX_COUNT) {
        throw "TIMEOUT,  too many failed test cases!";
      }
      let postState = await ctx.getState();
      assert(null == postState || postState == 0 || postState == 0, "postCondition violated: current state is " + postState);
      // PostCondition. 
    }
    return ret;
  }
  async action_unbid() {
    let ret = [];
    if (asyncFlag) {
      // bcos success status:0
      let executeStatus = BigInt(0);
      let ctx = StateMachineCtx.getInstance();
      let count = 0;
      // PreCondition. 
      let preState = await ctx.getState();
      assert(null == preState || preState == 3, "preCondition violated: current state is " + preState);

      let retunbid = await StateMachineCtx.getInstance().BlindAuction.unbid();
      ret.push(retunbid);
      console.log("current test case: ", BigInt(retunbid.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
      executeStatus += BigInt(retunbid.receipt.status.toString());
      while (executeStatus != 0 && count < MAX_COUNT) {
        count++;
        executeStatus = BigInt(0);
        let retunbid = await StateMachineCtx.getInstance().BlindAuction.unbid();
        ret.push(retunbid);
        console.log("current test case: ", BigInt(retunbid.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
        executeStatus += BigInt(retunbid.receipt.status.toString());
      }

      if (count >= MAX_COUNT) {
        throw "TIMEOUT,  too many failed test cases!";
      }
      let postState = await ctx.getState();
      assert(null == postState || postState == 3, "postCondition violated: current state is " + postState);
      // PostCondition. 
    }
    return ret;
  }
  async action_close() {
    let ret = [];
    if (asyncFlag) {
      // bcos success status:0
      let executeStatus = BigInt(0);
      let ctx = StateMachineCtx.getInstance();
      let count = 0;
      // PreCondition. 
      let preState = await ctx.getState();
      assert(null == preState || preState == 0, "preCondition violated: current state is " + preState);

      let retclose = await StateMachineCtx.getInstance().BlindAuction.close();
      ret.push(retclose);
      console.log("current test case: ", BigInt(retclose.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
      executeStatus += BigInt(retclose.receipt.status.toString());
      while (executeStatus != 0 && count < MAX_COUNT) {
        count++;
        executeStatus = BigInt(0);
        let retclose = await StateMachineCtx.getInstance().BlindAuction.close();
        ret.push(retclose);
        console.log("current test case: ", BigInt(retclose.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
        executeStatus += BigInt(retclose.receipt.status.toString());
      }

      if (count >= MAX_COUNT) {
        throw "TIMEOUT,  too many failed test cases!";
      }
      let postState = await ctx.getState();
      assert(null == postState || postState == 1, "postCondition violated: current state is " + postState);
      // PostCondition. 
    }
    return ret;
  }
  async action_reveal() {
    let ret = [];
    if (asyncFlag) {
      // bcos success status:0
      let executeStatus = BigInt(0);
      let ctx = StateMachineCtx.getInstance();
      let count = 0;
      // PreCondition. 
      let preState = await ctx.getState();
      assert(null == preState || preState == 1, "preCondition violated: current state is " + preState);

      let retreveal = await StateMachineCtx.getInstance().BlindAuction.reveal();
      ret.push(retreveal);
      console.log("current test case: ", BigInt(retreveal.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
      executeStatus += BigInt(retreveal.receipt.status.toString());
      while (executeStatus != 0 && count < MAX_COUNT) {
        count++;
        executeStatus = BigInt(0);
        let retreveal = await StateMachineCtx.getInstance().BlindAuction.reveal();
        ret.push(retreveal);
        console.log("current test case: ", BigInt(retreveal.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
        executeStatus += BigInt(retreveal.receipt.status.toString());
      }

      if (count >= MAX_COUNT) {
        throw "TIMEOUT,  too many failed test cases!";
      }
      let postState = await ctx.getState();
      assert(null == postState || postState == 1, "postCondition violated: current state is " + postState);
      // PostCondition. 
    }
    return ret;
  }
  async action_finish() {
    let ret = [];
    if (asyncFlag) {
      // bcos success status:0
      let executeStatus = BigInt(0);
      let ctx = StateMachineCtx.getInstance();
      let count = 0;
      // PreCondition. 
      let preState = await ctx.getState();
      assert(null == preState || preState == 1, "preCondition violated: current state is " + preState);

      let retfinish = await StateMachineCtx.getInstance().BlindAuction.finish();
      ret.push(retfinish);
      console.log("current test case: ", BigInt(retfinish.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
      executeStatus += BigInt(retfinish.receipt.status.toString());
      while (executeStatus != 0 && count < MAX_COUNT) {
        count++;
        executeStatus = BigInt(0);
        let retfinish = await StateMachineCtx.getInstance().BlindAuction.finish();
        ret.push(retfinish);
        console.log("current test case: ", BigInt(retfinish.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
        executeStatus += BigInt(retfinish.receipt.status.toString());
      }

      if (count >= MAX_COUNT) {
        throw "TIMEOUT,  too many failed test cases!";
      }
      let postState = await ctx.getState();
      assert(null == postState || postState == 2, "postCondition violated: current state is " + postState);
      // PostCondition. 
    }
    return ret;
  }
  async action_withdraw() {
    let ret = [];
    if (asyncFlag) {
      // bcos success status:0
      let executeStatus = BigInt(0);
      let ctx = StateMachineCtx.getInstance();
      let count = 0;
      // PreCondition. 
      let preState = await ctx.getState();
      assert(null == preState || preState == 2, "preCondition violated: current state is " + preState);

      let retwithdraw = await StateMachineCtx.getInstance().BlindAuction.withdraw();
      ret.push(retwithdraw);
      console.log("current test case: ", BigInt(retwithdraw.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
      executeStatus += BigInt(retwithdraw.receipt.status.toString());
      while (executeStatus != 0 && count < MAX_COUNT) {
        count++;
        executeStatus = BigInt(0);
        let retwithdraw = await StateMachineCtx.getInstance().BlindAuction.withdraw();
        ret.push(retwithdraw);
        console.log("current test case: ", BigInt(retwithdraw.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
        executeStatus += BigInt(retwithdraw.receipt.status.toString());
      }

      if (count >= MAX_COUNT) {
        throw "TIMEOUT,  too many failed test cases!";
      }
      let postState = await ctx.getState();
      assert(null == postState || postState == 2, "postCondition violated: current state is " + postState);
      // PostCondition. 
    }
    return ret;
  }
  async action_cancelRB() {
    let ret = [];
    if (asyncFlag) {
      // bcos success status:0
      let executeStatus = BigInt(0);
      let ctx = StateMachineCtx.getInstance();
      let count = 0;
      // PreCondition. 
      let preState = await ctx.getState();
      assert(null == preState || preState == 1, "preCondition violated: current state is " + preState);

      let retcancelRB = await StateMachineCtx.getInstance().BlindAuction.cancelRB();
      ret.push(retcancelRB);
      console.log("current test case: ", BigInt(retcancelRB.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
      executeStatus += BigInt(retcancelRB.receipt.status.toString());
      while (executeStatus != 0 && count < MAX_COUNT) {
        count++;
        executeStatus = BigInt(0);
        let retcancelRB = await StateMachineCtx.getInstance().BlindAuction.cancelRB();
        ret.push(retcancelRB);
        console.log("current test case: ", BigInt(retcancelRB.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
        executeStatus += BigInt(retcancelRB.receipt.status.toString());
      }

      if (count >= MAX_COUNT) {
        throw "TIMEOUT,  too many failed test cases!";
      }
      let postState = await ctx.getState();
      assert(null == postState || postState == 3, "postCondition violated: current state is " + postState);
      // PostCondition. 
    }
    return ret;
  }
  async action_cancelABB() {
    let ret = [];
    if (asyncFlag) {
      // bcos success status:0
      let executeStatus = BigInt(0);
      let ctx = StateMachineCtx.getInstance();
      let count = 0;
      // PreCondition. 
      let preState = await ctx.getState();
      assert(null == preState || preState == 0, "preCondition violated: current state is " + preState);

      let retcancelABB = await StateMachineCtx.getInstance().BlindAuction.cancelABB();
      ret.push(retcancelABB);
      console.log("current test case: ", BigInt(retcancelABB.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
      executeStatus += BigInt(retcancelABB.receipt.status.toString());
      while (executeStatus != 0 && count < MAX_COUNT) {
        count++;
        executeStatus = BigInt(0);
        let retcancelABB = await StateMachineCtx.getInstance().BlindAuction.cancelABB();
        ret.push(retcancelABB);
        console.log("current test case: ", BigInt(retcancelABB.receipt.status.toString()) == BigInt(0) ? "success" : "failed");
        executeStatus += BigInt(retcancelABB.receipt.status.toString());
      }

      if (count >= MAX_COUNT) {
        throw "TIMEOUT,  too many failed test cases!";
      }
      let postState = await ctx.getState();
      assert(null == postState || postState == 3, "postCondition violated: current state is " + postState);
      // PostCondition. 
    }
    return ret;
  }
}
// state machine 
const createStateMachine = statectx => {
  return Machine({
    id: "FSM#2",
    initial: "initial",
    context: {
      ctx: statectx
    },
    states: {

      initial: {
        on: {
          bid: {
            target: "ABB",
            actions: "action_bid"
          }
        }
      },
      ABB: {
        on: {
          bid: {
            target: "ABB",
            actions: "action_bid"
          },
          cancelABB: {
            target: "C",
            actions: "action_cancelABB"
          },
          close: {
            target: "RB",
            actions: "action_close"
          }
        }
      },
      RB: {
        on: {
          reveal: {
            target: "RB",
            actions: "action_reveal"
          },
          finish: {
            target: "F",
            actions: "action_finish"
          },
          cancelRB: {
            target: "C",
            actions: "action_cancelRB"
          }
        }
      },
      F: {
        on: {
          withdraw: {
            target: "F",
            actions: "action_withdraw"
          }
        }
      },
      C: {
        on: {
          unbid: {
            target: "C",
            actions: "action_unbid"
          }
        }
      }
    }
  }, {
    actions: {
      action_bid: statectx.action_bid,
      action_unbid: statectx.action_unbid,
      action_close: statectx.action_close,
      action_reveal: statectx.action_reveal,
      action_finish: statectx.action_finish,
      action_withdraw: statectx.action_withdraw,
      action_cancelRB: statectx.action_cancelRB,
      action_cancelABB: statectx.action_cancelABB
    }
  });
}

module.exports.StateMachineCtx = StateMachineCtx
module.exports.revertAsyncFlag = revertAsyncFlag;
module.exports.createStateMachine = createStateMachine